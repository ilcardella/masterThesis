\chapter{Implementation}
\label{cap5}

In this chapter we show how we implemented the Pluto Framework, describing the main elements of the project separately, in order to better understand their behaviors.
\\
In figure \ref{fig:finalArchitecture}, we show the final architecture scheme that includes all the parts described in the following sections.

 \begin{figure}[h!]
 \centering
 \includegraphics[width=\linewidth]
 {pictures/Final_Architecture.png}
 \caption{Pluto architecture representation}
 \label{fig:finalArchitecture}
 \end{figure}

\section{Graphical editor}\label{editor}

In order to create the Graphical Editor, described in section \ref{plutoGraphicalEditor}, we decided to use the GEF (Graphical Editing Framework) project. This framework is a Java technology and it is part of the Eclipse framework developed by IBM.
It gives developers a full solution for the  graphical modeling of a Java object model, and it can be used in conjunction with other technologies such as EMF (Eclipse Modeling Framework) or GMF (Graphical Modeling Framework), to enable the creation of a complete graphical modeling suite. 
This means that the Pluto Graphical Editor has been developed as an Eclipse Plugin, so the developer has to install the Eclipse IDE in order to exploit the editor.
\\

First of all, we created the Java classes of the blocks. Each class contains the code of the corresponding block.
We defined each block as a rectangle figure, then we added the connection entity in order to enable links between them. All these entities are children of a main container class that represent the diagram itself.
\\

When the user creates a new  block in the editor area, a relative block entity is automatically created and added to the diagram container class. The same operation stands for the connections creation.

After the user draws the desired graph he can choose to generate the final code of the Main Application, through the apposite voice in the context menu.
See section \ref{codeGeneration} for further details.
\\

\section{Code generation}\label{codeGeneration}

Once the programmer has created the graph of the application through the Pluto Graphical Editor, he can generate the code in order to make the Pluto Main Application behavior coherent with the graph.

This can be done by right clicking on the graph and choosing the "Generate code" command.

The Editor includes a template of the Main Application, in which  almost all the lines of code are ready to be executed.
However, this template contains several tags that the generation process will replace with specific lines of code, depending on the drawn graph.
\\

The generation process consists in the search for these tags inside the template application.
For example, there is a "<dec>" tag that is a placeholder for the declaration part of the created blocks. It means that this tag will be replaced with the declarations of the Java classes of the blocks.
\\

There are also tags that are placeholder for attribute values.
For example the "<tDelay>" tag will be replaced with a "true" or "false" string, depending on the presence of the Clock block in the diagram. 
This allow us to ask for a delay value for the trip, only if the developer has inserted a Clock block in the diagram. 
The same solution is adopted for the "Mission Repeater", "Timer Monitor" and "Priority Manager" blocks.
For each of them, there is a tag that will make the application ask the user for the respective values, if these blocks have been inserted in the graph.
\\

\subsection{From graph to code}\label{graphGen}

The main issue in the generation process was to understand how to generate the code from a general diagram. Potentially, a developer could draw a very complex graph with lot of blocks and connections between them.
At first,  we focused on graph exploration methods, but we immediately noticed that they were too complex.
So, we decided to adopt a \textit{Publish-Subscribe} design, making use of the \textit{Observer} pattern, shown in figure \ref{fig:observerPatter}.

 \begin{figure}[h!]
 \includegraphics[width=\linewidth]
 {pictures/pub_sub.png}
 \caption{Observer design pattern}
 \label{fig:observerPatter}
 \end{figure}

After the generation of the declaration part, we added an "<exe>" tag, that is replaced by the subscription part of the cited pattern. 
The \textit{Observer} pattern consists in the declaration of some elements as \textit{observers} and of other entities as \textit{observable}. 
When an observable object change its status, it sends a notification to all its observer entities. 
These observers will react according to the change of the observable object.
\\

In this way, we made each declared block both Observer and Observable. 
This means that each block observes another block that comes before it, but at the same time, it is observed by other blocks coming after it. 
The change of status consists in the output of the Mission object.
When a block ends to perform its operations, it notifies all its observers passing them the Mission entity. 
Then, all the observers take as an input that mission.
\\

This mechanism let us describe the execution flow of a virtually very complex diagram besides those that are more simple.


\section{Object-oriented approach}\label{oomodel}

We used the Java programming language to implement both the Graphical Editor and the Main Application.
We made this choice because we are very familiar with Java, since almost every academic project we implemented in these years made use of this Object-Oriented programming language.
The Object-Oriented approach perfectly suits the Pluto model, since we have different independent entities such Drones,Missions,Trips that interact together in the execution of tasks.
\\

We decided to adopt a Model View Controller(MVC) approach, whose functioning is shown in figure \ref{fig:mvc}.
The central component of MVC, the model, captures the behavior of the application in terms of its problem domain, independent of the user interface.
The model directly manages the data, logic and rules of the application.
A view can be any output representation of information, such as a chart or a diagram; multiple views of the same information are possible.
The third part, the controller, accepts input and converts it to commands for the model or view.

A controller can send commands to the model to update the model's state.
It can also send commands to its associated view to change the view's presentation of the model.
A model notifies its associated views and controllers when there has been a change in its state. This notification allows the views to produce updated output, and the controllers to change the available set of commands.
A view requests information from the model that it uses to generate an output representation to the user.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]
{pictures/MVC.png}
  \caption{The MVC pattern}
  \label{fig:mvc}
\end{figure}

\section{Runtime Management}\label{runtimeMng}

Figure 	\ref{fig:threads} shows as the Main Application manages the mission execution with a parallel programming architecture. 
Indeed when the user starts the execution, the system launches each mission in a new thread, in order to guarantee a reliable parallel execution.
\\

Then each mission starts its flow among the blocks, thanks to the Observer design pattern, described in section \ref{graphGen}.
When the mission enters in a new block, the application launches a new thread, in order to run the mission management code of the block.
We need this new thread because there is the possibility that two or more parallel blocks have to manage the same mission entity at the same time.
\\

Therefore, when the mission reaches the "Trip Launcher" block, the system starts the trip.
Doing this, it creates a new thread, to manage the trip execution till its end.
\\

As said, each mission and each trip created by the user, have a respective thread that deal with the execution of the entity from the beginning to the end. In this way, the blocks that need to monitor these entities can observe the status of the threads, in order to know if the trip/mission is still running or has already completed.
\\

 \begin{figure}[h!]
 \includegraphics[width=\linewidth]
 {pictures/threads.png}
 \caption{Example of thread concurrency}
 \label{fig:threads}
 \end{figure}

\section{User interface}\label{interface}

We chose the Swing framework to develop the Pluto User Interface, already described in section \ref{plutoMainApp}.
We made this choice since Swing is well known to us.
Indeed we used it for the development of many academic projects, where we noticed that it allows to build graphical interface in a very fast and easy way and to add a great variety of components.
\\

Swing library is an official Java GUI toolkit released by Sun Microsystems. It is used to create Graphical user interfaces with Java.
The main characteristics of the Swing toolkit are:
\begin{itemize}
\item platform independent
\item customizable
\item extensible
\item configurable
\item lightweight
\end{itemize}

Swing is an advanced GUI toolkit. It has a rich set of widgets:
from basic widgets like buttons, labels, scrollbars to advanced like trees and tables. 
Swing itself is written in Java and is part of JFC, Java Foundation Classes: it is a collection of packages for creating full featured desktop applications.

There are basically two types of widget toolkits: \textit{Lightweight} and \textit{Heavyweight}.
A heavyweight toolkit uses OS's API to draw the widgets. For example Borland's VCL is a heavyweight toolkit since it depends on WIN32 API, the built in Windows application programming interface.
As already said, Swing is a lightweight toolkit since it paints its own widgets.

\section{The crazyflie nano-quadcopter}\label{crazyflie}

For the concrete actuation of the sensing tasks required by each application, we chose the Crazyflie Nano-Quadcopter, shown in figure \ref{fig:crazyflie}.


\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]
{pictures/crazyflie.jpg}
  \caption{The Crazyflie Nano-Quadcopter}
  \label{fig:crazyflie}
\end{figure}

The Crazyflie is a tiny quadcopter often referred to as a nano-quad, built using the PCB itself as the frame,developed solely by open source tools. The Crazyflie specs are the following:


\begin{itemize}
\item {Small and lightweight, around 19g and about 90mm motor to motor
}
\item {Flight time up to 7 minutes with standard 170mAh Li-Po battery
}
\item {Standard micro-USB connector for charging which takes 20min for the stock 170mAh Li-Po battery
}
\item {On-board low-energy radio@1mW based on the nRF24L01+ chip. Up to 80m range (environment dependent) when using the Crazyradio USB dongle}
\item{Radio bootloader which enables wireless update of the firmware
}
\item{Powerful 32 bit MCU: STM32F103CB @ 72 MHz (128kb flash, 20kb RAM)
}
\item{3-axis high-performance MEMs gyros with 3-axis accelerometer: Invensense MPU-6050
}
\item{Available footprints to manually solder magnetometer HMC5883L/HMC5983 or/and barometer MS5611
}
\item{4-layer low noise PCB design with separate voltage regulators for digital and analog supply
}
\end{itemize}

To concretely control the Crazyflie, there is a Python library which gives high level functions and hides the details.
We used a particular API to send the control command: 
\\

\begin{lstlisting}
	send_setpoint(roll, pitch, yaw, thrust)
\end{lstlisting}

The arguments roll/pitch/yaw/trust is the new set-points that should be sent to the copter.
For example, to send a new control set-point:
\\

\begin{lstlisting}
	 roll    = 0.0
    pitch   = 0.0
    yawrate = 0
    thrust  = 0
    crazyflie.commander.send_setpoint(roll, pitch, yawrate, thrust)
\end{lstlisting}

Changing the \textit{roll} and \textit{pitch} will make the quadcopter tilt to the sides and thus change the direction that it's moving in.
Changing the \textit{yaw} will make the quadcopter spin.
The thrust is used to control the altitude of the quadcopter.

By dynamically adjusting these four parameters we can make the Crazyflies move to the locations specified by the user through the Pluto User Interface.


